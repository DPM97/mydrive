package routes

import (
	"context"
	"database/sql"
	"encoding/base32"
	"net/http"
	"net/url"

	"github.com/DPM97/mydrive/backend/pkg/auth"
	"github.com/DPM97/mydrive/backend/pkg/rand"
	"github.com/gin-contrib/sessions"
	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v4"
)

type User struct {
	ID        sql.NullInt32  `json:"id"`
	Email     sql.NullString `json:"email"`
	OTPSecret sql.NullString `json:"OTPSecret"`
}

func AuthRequired(c *gin.Context) {
	session := sessions.Default(c)
	user := session.Get("user")
	if user == nil {
		// Abort the request with the appropriate error code
		c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	// Continue down the chain to handler etc
	c.Next()
	return
}

func CheckIfPublicHandler(db *pgx.Conn) gin.HandlerFunc {
	fn := func(c *gin.Context) {
		session := sessions.Default(c)
		user := session.Get("user")

		if user != nil && len(c.Param("id")) != 100 {
			return
		}

		fetchByPIDQuery := `
      select id from files
      where pid = $1
    `

		rows, err := db.Query(context.Background(), fetchByPIDQuery, c.Param("id"))

		if err != nil {
			c.String(http.StatusBadRequest, "Could not fetch file.")
			return
		}

		rows.Next()

		var id sql.NullInt32
		rows.Scan(&id)

		rows.Close()

		if id.Valid == false {
			c.String(http.StatusNotFound, "File does not exist.")
			return
		}

		c.Next()
	}

	return gin.HandlerFunc(fn)
}

// include email in here so we can make sure they match when making the final request
type FetchQRResponse struct {
	URI    string `json:"uri"`
	Email  string `json:"email"`
	Secret string `json:"secret"`
}

func FetchQRHandler(db *pgx.Conn) gin.HandlerFunc {
	fn := func(c *gin.Context) {

		// generate a random otp secret
		otp_secret := base32.StdEncoding.EncodeToString([]byte(rand.Generate(20)))

		autheticator := auth.GenConfig(otp_secret)

		uri := autheticator.ProvisionURIWithIssuer(c.Query("email"), url.QueryEscape("mydrive.DPM97.github"))

		c.JSON(http.StatusOK, &FetchQRResponse{
			URI:    uri,
			Email:  c.Query("email"),
			Secret: otp_secret,
		})

		return
	}

	return gin.HandlerFunc(fn)
}

// include email in here so we can make sure they match when making the final request
type CreateAcctBody struct {
	Email     string `json:"email"`
	OTPSecret string `json:"OTPSecret"`
}

func CreateAcctHandler(db *pgx.Conn) gin.HandlerFunc {
	fn := func(c *gin.Context) {

		var formData CreateAcctBody
		c.BindJSON(&formData)

		createTableQuery := `
      create table if not exists users(
        id integer generated by default as identity primary key,
        email text,
        otp_secret text
      )
    `

		if _, err := db.Exec(context.Background(), createTableQuery); err != nil {
			c.String(http.StatusBadRequest, "failed to create users table.")
			return
		}

		// check if user with this email alr. exists
		fetchQuery := `
      select id from users
      where email = $1
    `

		rows, err := db.Query(context.Background(), fetchQuery, formData.Email)

		if err != nil {
			c.String(http.StatusBadRequest, "failed to query for pre-existing user w/ this email.")
			return
		}

		rows.Next()
		var preExistingId sql.NullInt32
		rows.Scan(&preExistingId)

		rows.Close()

		if preExistingId.Valid == true {
			c.String(http.StatusBadRequest, "an account with this email already exists.")
			return
		}

		// now we can create the account
		createQuery := `
      insert into
      users(email, otp_secret)
      values($1, $2)
    `

		if _, err := db.Exec(context.Background(), createQuery, formData.Email, formData.OTPSecret); err != nil {
			c.String(http.StatusBadRequest, "failed to create user.")
			return
		}

		return
	}

	return gin.HandlerFunc(fn)
}

type LoginBody struct {
	Email string `json:"email"`
	OTP   string `json:"otp"`
}

func LoginHandler(db *pgx.Conn) gin.HandlerFunc {
	fn := func(c *gin.Context) {
		session := sessions.Default(c)

		var formData LoginBody
		c.BindJSON(&formData)

		// get user associated with the email
		fetchQuery := `
    select id, otp_secret from users
    where email = $1
    `

		rows, err := db.Query(context.Background(), fetchQuery, formData.Email)

		if err != nil {
			c.String(http.StatusBadRequest, "failed to query for pre-existing user w/ this email.")
			return
		}

		rows.Next()
		var uID sql.NullInt32
		var OTPSecret sql.NullString
		rows.Scan(&uID, &OTPSecret)

		rows.Close()

		if uID.Valid == false || OTPSecret.Valid == false {
			c.String(http.StatusBadRequest, "an account does not exist with this email.")
			return
		}

		// create an authenticator for this user
		authenticator := auth.GenConfig(OTPSecret.String)

		if isValid, err := authenticator.Authenticate(formData.OTP); !isValid || err != nil {
			c.String(http.StatusUnauthorized, "Authentication failed. Please try again.")
			return
		}

		session.Set("user", uID.Int32)

		// 24hr session
		session.Options(sessions.Options{
			MaxAge: 3600 * 24,
		})

		if err := session.Save(); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save session"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "Successfully authenticated user"})
		return
	}

	return gin.HandlerFunc(fn)
}

func LogoutHandler() gin.HandlerFunc {
	fn := func(c *gin.Context) {
		session := sessions.Default(c)
		user := session.Get("user")
		if user == nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid session token"})
			return
		}
		session.Delete("user")
		if err := session.Save(); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save session"})
			return
		}
		c.JSON(http.StatusOK, gin.H{"message": "Successfully logged out"})
		return
	}

	return gin.HandlerFunc(fn)
}
