package routes

import (
	"context"
	"database/sql"

	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v4"
)

type File struct {
	ID          sql.NullInt32  `json:"id"`
	PID         sql.NullString `json:"pid"`
	LOID        sql.NullInt32  `json:"loid"`
	Path        sql.NullString `json:"path"`
	Uploaded_at sql.NullTime   `json:"uploaded_at"`
	Name        sql.NullString `json:"name"`
	File_type   sql.NullString `json:"file_type"`
	Size        sql.NullInt32  `json:"size"`
}

func FetchDocumentHandler(db *pgx.Conn) gin.HandlerFunc {
	fn := func(c *gin.Context) {

		relPath := c.Query("relativePath")

		// for now we just fetch all documents with nil pid (root directory)

		createQuery := `
			create table if not exists files(
				id integer generated by default as identity primary key,
				pid text,
				loid integer,
				path text,
				uploaded_at timestamp with time zone default now(),
				name text,
				file_type text,
				size int
			)
		`

		if _, err := db.Exec(context.Background(), createQuery); err != nil {

			c.String(400, "failed to create files table.")
			return
		}

		var fetchQuery string
		fetchQuery = `
			select * from files
			where path = $1
		`

		rows, err := db.Query(context.Background(), fetchQuery, relPath)

		if err != nil {
			c.String(400, "query failed")
			return
		}

		items := make([]File, 0)

		for rows.Next() {
			var item File
			rows.Scan(
				&item.ID,
				&item.PID,
				&item.LOID,
				&item.Path,
				&item.Uploaded_at,
				&item.Name,
				&item.File_type,
				&item.Size,
			)

			items = append(items, item)
		}

		rows.Close()

		c.JSON(200, items)
		return
	}

	return gin.HandlerFunc(fn)
}

func DeleteDocumentHandler(db *pgx.Conn) gin.HandlerFunc {
	fn := func(c *gin.Context) {

		findLoQuery := `
			select loid from files
			where id = $1
		`

		rows, err := db.Query(context.Background(), findLoQuery, c.Param("id"))

		if err != nil {
			c.String(400, "no document with this id exists.")
			return
		}

		rows.Next()

		var loid sql.NullInt32
		rows.Scan(&loid)

		rows.Close()

		// begin fetch sequence
		tx, err := db.Begin(context.Background())

		if err != nil {

			c.String(400, "failed to start transaction.")
			tx.Rollback(context.TODO())
			return
		}

		lo := tx.LargeObjects()

		if err := lo.Unlink(context.Background(), uint32(loid.Int32)); err != nil {
			c.String(400, "failed to remove large object for file.")
			tx.Rollback(context.TODO())
			return
		}

		if err := tx.Commit(context.Background()); err != nil {
			c.String(400, "failed to commit transaction.")
			tx.Rollback(context.TODO())
			return
		}

		deleteQuery := `
			delete from files
			where id = $1
		`

		if _, err := db.Exec(context.Background(),
			deleteQuery,
			c.Param("id"),
		); err != nil {
			c.String(400, "could not delete file.")
			return
		}

		c.JSON(200, "success")
		return
	}

	return gin.HandlerFunc(fn)
}

type CreateFolderForm struct {
	RelativePath string `json:"relativePath"`
	Name         string `json:"name"`
}

func CreateFolderHandler(db *pgx.Conn) gin.HandlerFunc {
	fn := func(c *gin.Context) {

		var formData CreateFolderForm
		c.BindJSON(&formData)

		// for now we just fetch all documents with nil pid (root directory)

		insertQuery := `
			insert into
			files(file_type, name, path)
			values($1, $2, $3)
		`

		if _, err := db.Exec(context.Background(),
			insertQuery,
			"folder",
			formData.Name,
			formData.RelativePath); err != nil {

			c.String(400, "could not create folder.")
			return
		}

		c.String(200, "folder created.")
		return
	}

	return gin.HandlerFunc(fn)
}

func DeleteFolderHandler(db *pgx.Conn) gin.HandlerFunc {
	fn := func(c *gin.Context) {

		fidQuery := `
		select path, name from files
		where id = $1
		`

		rows, err := db.Query(context.Background(),
			fidQuery,
			c.Param("id"),
		)

		if err != nil {
			c.String(400, "no document with this id exists.")
			return
		}

		rows.Next()

		var folderPath sql.NullString
		var folderName sql.NullString
		rows.Scan(&folderPath, &folderName)

		rows.Close()

		findLoQuery := `
		select loid from files
		where
		(path like $1)
		and
		(loid is not null)
	`

		rows, err = db.Query(context.Background(),
			findLoQuery,
			folderPath.String+folderName.String+"%",
		)

		if err != nil {
			c.String(400, "error fetching large objects.")
			return
		}

		loids := make([]uint32, 0)
		for rows.Next() {
			var loid sql.NullInt32
			rows.Scan(&loid)
			loids = append(loids, uint32(loid.Int32))
		}

		rows.Close()

		// begin large object deletion sequence
		tx, err := db.Begin(context.Background())

		if err != nil {

			c.String(400, "failed to start transaction.")
			tx.Rollback(context.TODO())
			return
		}

		lo := tx.LargeObjects()

		for _, loid := range loids {
			if err := lo.Unlink(context.Background(), loid); err != nil {
				c.String(400, "failed to remove object.")
				tx.Rollback(context.TODO())
				return
			}
		}

		if err := tx.Commit(context.Background()); err != nil {
			c.String(400, "failed to commit transaction.")
			tx.Rollback(context.TODO())
			return
		}

		deleteQuery := `
			delete from files
			where 
			(file_type = $1 and id = $2)
			or
			(path like $3)
		`

		if _, err := db.Exec(context.Background(),
			deleteQuery,
			"folder",
			c.Param("id"),
			folderPath.String+folderName.String+"%",
		); err != nil {
			c.String(400, "could not delete folder.")
			return
		}

		c.String(200, "folder deleted.")
		return
	}

	return gin.HandlerFunc(fn)
}
